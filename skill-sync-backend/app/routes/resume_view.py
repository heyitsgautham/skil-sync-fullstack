"""
Resume View/Download Routes with Anonymization Support
Handles viewing and downloading resumes with on-demand anonymization
"""

import os
import tempfile
import logging
from datetime import datetime, timedelta
from typing import Optional
from fastapi import APIRouter, Depends, HTTPException, status, Query
from fastapi.responses import StreamingResponse, FileResponse
from sqlalchemy.orm import Session
from io import BytesIO
import jwt

from app.database.connection import get_db
from app.models import User, Resume, UserRole
from app.services.s3_service import s3_service
from app.services.resume_anonymization_service import anonymization_service
from app.utils.security import get_current_user

router = APIRouter(prefix="/resumes", tags=["Resume Viewing"])
logger = logging.getLogger(__name__)

# Secret key for signing temporary tokens (use environment variable in production)
TEMP_TOKEN_SECRET = os.getenv("TEMP_TOKEN_SECRET", "your-secret-key-change-in-production")


def get_optional_user(
    token: Optional[str] = Query(None),
    db: Session = Depends(get_db)
):
    """Get current user or None if using temporary token"""
    if token:
        # Using temporary token, skip user authentication
        return None
    try:
        from app.utils.security import get_current_user_direct
        return get_current_user_direct(db)
    except:
        raise HTTPException(status_code=401, detail="Authentication required")


@router.get("/{resume_id}/view")
async def view_resume(
    resume_id: int,
    token: Optional[str] = Query(None, description="Temporary access token"),
    db: Session = Depends(get_db)
):
    """
    View a resume (with optional anonymization for companies)
    
    - **resume_id**: ID of the resume to view
    - **token**: Temporary access token (required - generated by backend)
    - Streams PDF directly to browser
    - Original S3 files are never modified
    """
    
    try:
        anonymize = False
        
        # Verify temporary token (required)
        if not token:
            raise HTTPException(
                status_code=status.HTTP_401_UNAUTHORIZED,
                detail="Access token required"
            )
        
        try:
            payload = jwt.decode(token, TEMP_TOKEN_SECRET, algorithms=["HS256"])
            
            # Verify token is for this resume
            if payload.get("resume_id") != resume_id:
                raise HTTPException(
                    status_code=status.HTTP_403_FORBIDDEN,
                    detail="Invalid token for this resume"
                )
            
            # Token is valid, proceed without authentication
            logger.info(f"üìÑ Accessing resume {resume_id} with temporary token")
            anonymize = payload.get("anonymize", False)
            
        except jwt.ExpiredSignatureError:
            raise HTTPException(
                status_code=status.HTTP_401_UNAUTHORIZED,
                detail="Temporary access token has expired"
            )
        except jwt.InvalidTokenError:
            raise HTTPException(
                status_code=status.HTTP_401_UNAUTHORIZED,
                detail="Invalid temporary access token"
            )
        
        # Get resume from database
        resume = db.query(Resume).filter(Resume.id == resume_id).first()
        
        if not resume:
            raise HTTPException(
                status_code=status.HTTP_404_NOT_FOUND,
                detail="Resume not found"
            )
        
        # Get student info for anonymization
        student = db.query(User).filter(User.id == resume.student_id).first()
        
        if not student:
            raise HTTPException(
                status_code=status.HTTP_404_NOT_FOUND,
                detail="Student not found"
            )
        
        # Download PDF from S3 or use local file
        temp_file_path = None
        
        try:
            if resume.s3_key and s3_service.is_enabled():
                # Download from S3 to temporary location
                logger.info(f"‚òÅÔ∏è Downloading resume from S3: {resume.s3_key}")
                temp_file_path = os.path.join(tempfile.gettempdir(), f"resume_{resume_id}_{os.urandom(8).hex()}.pdf")
                
                success = s3_service.download_resume(resume.s3_key, temp_file_path)
                
                if not success:
                    raise HTTPException(
                        status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
                        detail="Failed to download resume from S3"
                    )
                
                pdf_path = temp_file_path
            else:
                # Use local file
                if not os.path.exists(resume.file_path):
                    raise HTTPException(
                        status_code=status.HTTP_404_NOT_FOUND,
                        detail="Resume file not found"
                    )
                pdf_path = resume.file_path
            
            # Check if anonymization is requested
            if anonymize:
                logger.info(f"üîí Anonymizing resume for {student.full_name}")
                
                # Anonymize the PDF (returns bytes)
                anonymized_pdf_bytes = anonymization_service.anonymize_resume_from_file(
                    input_pdf_path=pdf_path,
                    full_name=student.full_name,
                    email=student.email,
                    phone=student.phone,
                    linkedin_url=student.linkedin_url,
                    github_url=student.github_url
                )
                
                # Clean up temp file if downloaded from S3
                if temp_file_path and os.path.exists(temp_file_path):
                    os.remove(temp_file_path)
                    logger.info(f"üóëÔ∏è Cleaned up temp file: {temp_file_path}")
                
                # Return anonymized PDF as streaming response
                return StreamingResponse(
                    BytesIO(anonymized_pdf_bytes),
                    media_type="application/pdf",
                    headers={
                        "Content-Disposition": f'inline; filename="anonymized_{resume.file_name}"'
                    }
                )
            else:
                # Return original PDF
                logger.info(f"üìÑ Serving original resume: {resume.file_name}")
                
                # If using S3 temp file, serve it and clean up after
                if temp_file_path:
                    return FileResponse(
                        temp_file_path,
                        media_type="application/pdf",
                        headers={
                            "Content-Disposition": f'inline; filename="{resume.file_name}"'
                        },
                        background=lambda: os.remove(temp_file_path) if os.path.exists(temp_file_path) else None
                    )
                else:
                    # Serve local file directly
                    return FileResponse(
                        pdf_path,
                        media_type="application/pdf",
                        headers={
                            "Content-Disposition": f'inline; filename="{resume.file_name}"'
                        }
                    )
        
        except Exception as e:
            # Clean up temp file on error
            if temp_file_path and os.path.exists(temp_file_path):
                os.remove(temp_file_path)
            raise
    
    except HTTPException:
        raise
    except Exception as e:
        logger.error(f"  Error viewing resume: {str(e)}")
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail=f"Error viewing resume: {str(e)}"
        )


@router.get("/{resume_id}/download")
async def download_resume(
    resume_id: int,
    anonymize: bool = Query(False, description="Whether to anonymize the resume"),
    db: Session = Depends(get_db),
    current_user: User = Depends(get_current_user)
):
    """
    Download a resume (with optional anonymization for companies)
    
    - **resume_id**: ID of the resume to download
    - **anonymize**: If True, downloads anonymized version
    - Forces download instead of inline viewing
    """
    
    # Same logic as view_resume, but with 'attachment' instead of 'inline'
    try:
        resume = db.query(Resume).filter(Resume.id == resume_id).first()
        
        if not resume:
            raise HTTPException(
                status_code=status.HTTP_404_NOT_FOUND,
                detail="Resume not found"
            )
        
        student = db.query(User).filter(User.id == resume.student_id).first()
        
        if not student:
            raise HTTPException(
                status_code=status.HTTP_404_NOT_FOUND,
                detail="Student not found"
            )
        
        # Authorization check
        if current_user.role == UserRole.student:
            if current_user.id != resume.student_id:
                raise HTTPException(
                    status_code=status.HTTP_403_FORBIDDEN,
                    detail="You can only download your own resumes"
                )
        elif current_user.role == UserRole.company:
            if current_user.anonymization_enabled and not anonymize:
                anonymize = True
                logger.info(f"üîí Forcing anonymization for company {current_user.id} (admin toggle enabled)")
        elif current_user.role != UserRole.admin:
            raise HTTPException(
                status_code=status.HTTP_403_FORBIDDEN,
                detail="Insufficient permissions"
            )
        
        # Get PDF (from S3 or local)
        temp_file_path = None
        
        try:
            if resume.s3_key and s3_service.is_enabled():
                logger.info(f"‚òÅÔ∏è Downloading resume from S3: {resume.s3_key}")
                temp_file_path = os.path.join(tempfile.gettempdir(), f"resume_{resume_id}_{os.urandom(8).hex()}.pdf")
                
                success = s3_service.download_resume(resume.s3_key, temp_file_path)
                
                if not success:
                    raise HTTPException(
                        status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
                        detail="Failed to download resume from S3"
                    )
                
                pdf_path = temp_file_path
            else:
                if not os.path.exists(resume.file_path):
                    raise HTTPException(
                        status_code=status.HTTP_404_NOT_FOUND,
                        detail="Resume file not found"
                    )
                pdf_path = resume.file_path
            
            if anonymize:
                logger.info(f"üîí Anonymizing resume for download: {student.full_name}")
                
                anonymized_pdf_bytes = anonymization_service.anonymize_resume_from_file(
                    input_pdf_path=pdf_path,
                    full_name=student.full_name,
                    email=student.email,
                    phone=student.phone,
                    linkedin_url=student.linkedin_url,
                    github_url=student.github_url
                )
                
                if temp_file_path and os.path.exists(temp_file_path):
                    os.remove(temp_file_path)
                
                return StreamingResponse(
                    BytesIO(anonymized_pdf_bytes),
                    media_type="application/pdf",
                    headers={
                        "Content-Disposition": f'attachment; filename="anonymized_{resume.file_name}"'
                    }
                )
            else:
                logger.info(f"üì• Downloading original resume: {resume.file_name}")
                
                if temp_file_path:
                    return FileResponse(
                        temp_file_path,
                        media_type="application/pdf",
                        filename=resume.file_name,
                        background=lambda: os.remove(temp_file_path) if os.path.exists(temp_file_path) else None
                    )
                else:
                    return FileResponse(
                        pdf_path,
                        media_type="application/pdf",
                        filename=resume.file_name
                    )
        
        except Exception as e:
            if temp_file_path and os.path.exists(temp_file_path):
                os.remove(temp_file_path)
            raise
    
    except HTTPException:
        raise
    except Exception as e:
        logger.error(f"  Error downloading resume: {str(e)}")
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail=f"Error downloading resume: {str(e)}"
        )
